# 题目描述
# hard
# 32. 最长有效括号
"""
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"

示例 2：
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"

示例 3：
输入：s = ""
输出：0

提示：
    0 <= s.length <= 3 * 104
    s[i] 为 '(' 或 ')'

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-valid-parentheses
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

===================================================================
题解：
    动态规划求解，本题关键在于构造递推关系。
    将dp[i]定义为以s[i]结尾的字串的最长有效括号长度，那么首先可以确定dp[i] = 0 if s[i] == "("
    因此，只考虑s[i] == ")"的情况。考虑它的上一个dp[i-1]，分情况讨论：
    - 如果s[i-1] == "("，那么就成了 xxxxxx()的形式。自然地，有：dp[i] = dp[i-2] + 2
    - 如果s[i-1] == ")"，即xxxxxx))的形式，首先，我们应该将i-1处的右括号消去，通过找到它所对应的最长的合法括号，即dp[i-1]。
        减去这部分合法括号以后，就变成了 xxx[合法部分]）的形式，此时，只要[合法部分]前面一个为左括号，就可以约掉s[i]的右括号，形成新的有效括号。
        此时，有：dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2 if dp[i-dp[i-1]-1] == "("
        dp[i-1]就是[合法部分]的长度、dp[i-dp[i-1]-2]就是消掉了”([合法部分])“之后，前面的那一段长度、最后的+2就是合法部分两侧的括号。
    根据该递推关系，即可填充dp矩阵，最后需要求最大。

"""

# 执行用时：28 ms, 在所有 Python 提交中击败了89.79% 的用户
# 内存消耗：13.8 MB, 在所有 Python 提交中击败了16.73% 的用户
class Solution(object):
    def longestValidParentheses(self, s):
        """
        :type s: str
        :rtype: int
        """
        if not s:
            return 0
        n = len(s)
        dp = [0 for _ in range(n)]
        
        for i in range(1, n):
            if s[i] == "(":
                continue
            if s[i - 1] == "(":
                if i - 2 >= 0:
                    dp[i] = dp[i - 2] + 2
                else:
                    dp[i] = 2
            else:
                # 注意数组越界问题，python的越界变负数也是合法的，因此不容易发现bug
                if i - dp[i - 1] - 1 < 0:
                    dp[i] = 0
                else:
                    if s[i - dp[i - 1] - 1] == "(":
                        dp[i] = dp[i - dp[i - 1] - 2] + dp[i - 1] + 2        
        return max(dp)
